<%- include ("partials/header") -%>
	<script>
		var majstori = <%-JSON.stringify(majstori)%>;
		majstori.sort((a, b) => a.ime.localeCompare(b.ime));
		var dodele = <%-JSON.stringify(dodele)%>;
		for(var i=0;i<majstori.length;i++){
			majstori[i].dodele = [];
			for(var j=0;j<dodele.length;j++){
				if(majstori[i].uniqueId==dodele[j].majstor){
					majstori[i].dodele.push(dodele[j])
				}
			}
		}

		

		var START_H = 7
		var START_M = 0;   // 07:00
		var END_H   = 21;
		var END_M   = 0;  // 20:00
		var STEP_MIN = 30; 
		var hour = START_H;
		var minute = START_M;
		var times = [];
		while (hour < END_H || (hour === END_H && minute === END_M)) {
		    const h = String(hour).padStart(2,'0');
		    const m = String(minute).padStart(2,'0');
		    times.push(`${h}:${m}`);
		    minute += STEP_MIN;
		    if (minute >= 60) { minute = 0; hour++; }
		}

		function getTopForTime(timeStr) {
			// ---- Config (same as your generation logic) ----
			const START_H = 7;
			const START_M = 0;
			const STEP_MIN = 30; // half-hour per row
			const timeline = document.querySelector('.rasporedRadovaUzivo');
			const sample = document.querySelector('.timestamp');
			if (!timeline || !sample) return 0;

			// ---- Convert "HH:MM" into total minutes ----
			const [h, m] = timeStr.split(':').map(Number);
			const targetMin = h * 60 + m;
			const startMin = START_H * 60 + START_M;
			const diffMin = targetMin - startMin;
			if (diffMin < 0) return 0; // before start

			// ---- Compute position ----
			const slotH = sample.offsetHeight; // height of each timestamp row
			const padTop = parseFloat(getComputedStyle(timeline).paddingTop) || 0;
			const slots = diffMin / STEP_MIN;
			const topPx = padTop + slots * slotH;

			return topPx;
		}

		function getHeightForDuration(durationStr) {
			const STEP_MIN = 30; // one .timestamp = 30 minutes
			const sample = document.querySelector('.timestamp');
			if (!sample) return 0;

			const slotH = sample.offsetHeight;

			// Parse duration "HH:MM"
			const [h, m] = durationStr.split(':').map(Number);
			const totalMin = h * 60 + m;

			// Convert minutes to pixels
			const height = (totalMin / STEP_MIN) * slotH;

			return height;
		}

		function adjustLeftPositionsTight(elem) {
		  const container = elem;
		  if (!container) return;

		  const wraps = Array.from(container.querySelectorAll(".dodelaWrap"));
		  if (!wraps.length) return;

		  // Make sure container is positioning context
		  if (getComputedStyle(container).position === "static") {
		    container.style.position = "relative";
		  }

		  // Sort by vertical position so earlier items become anchors
		  wraps.sort((a, b) => {
		    const ta = parseFloat(a.style.top) || 0;
		    const tb = parseFloat(b.style.top) || 0;
		    return ta - tb || a.offsetHeight - b.offsetHeight;
		  });

		  // Reset any previous left
		  wraps.forEach(el => { el.style.left = "0px"; });

		  const GAP = 4; // px space between neighbors

		  for (let i = 0; i < wraps.length; i++) {
		    const a = wraps[i];
		    const aTop = parseFloat(a.style.top) || 0;
		    const aBottom = aTop + a.offsetHeight;

		    // Find the rightmost edge among *previous* overlapping elements
		    let left = 0;
		    for (let j = 0; j < i; j++) {
		      const b = wraps[j];
		      const bTop = parseFloat(b.style.top) || 0;
		      const bBottom = bTop + b.offsetHeight;

		      const overlapsVertically = aTop < bBottom && aBottom > bTop;
		      if (overlapsVertically) {
		        const bLeft = parseFloat(b.style.left) || 0;
		        const bRight = bLeft + b.offsetWidth;
		        if (bRight > left) left = bRight; // park right after the farthest-right overlap
		      }
		    }

		    // Small gap so edges don’t touch
		    if (left > 0) left += GAP;

		    // Optional: keep inside container
		    const maxLeft = Math.max(0, container.clientWidth - a.offsetWidth);
		    if (left > maxLeft) left = maxLeft;

		    a.style.left = left + "px";
		    a.style.position = "absolute"; // make sure it’s absolutely positioned
		  }
		}

		 function getNowTopPx() {
    const sample = document.querySelector('.timestamp');
    if (!sample) return 0;
    const slotH = sample.offsetHeight;               // px per 30min
    const now = new Date();
    let h = now.getHours(), m = now.getMinutes();

    // clamp to schedule window
    const startMin = START_H*60 + START_M;
    const endMin   = END_H*60   + END_M;
    const nowMin   = Math.min(Math.max(h*60 + m, startMin), endMin);

    // allow smooth, fractional position (not just on 30-min grid)
    const slots = (nowMin - startMin) / STEP_MIN;   // e.g., 09:15 -> 4.5 slots from 07:00
    return slots * slotH;
  }

		function scrollWrappersToNow({align = 'center', extraOffset = 0, contentOffsetY = 0} = {}) {
  const topPx = getNowTopPx();
  const wrappers = document.querySelectorAll('.rasporedRadovaUzivo .wrapper');

  wrappers.forEach(wrap => {
    const header = wrap.querySelector('.ime');
    const headerH = header ? header.offsetHeight : 0;

    let target = topPx;
    if (align === 'center') {
      target = topPx - (wrap.clientHeight - headerH) / 2;
    } else if (align === 'start') {
      target = Math.max(0, topPx - headerH);
    } else if (align === 'end') {
      target = topPx - (wrap.clientHeight - headerH);
    }
    target = Math.max(0, target + extraOffset);

    // 1) scroll
    wrap.scrollTo({ top: target, behavior: 'smooth' });
    
  });
}

function ensureBrojNalogaVisible({
  basePad = 0,
  extraY  = 0,
  maxPad  = 200
} = {}) {
  document.querySelectorAll('.dodelaWrap').forEach(box => {
    const broj  = box.querySelector('.brojNaloga');
    if (!broj) return;

    const wrap  = box.closest('.wrapper');
    if (!wrap) return;

    const header = wrap.querySelector('.ime');
    const headerH = header ? header.offsetHeight : 0;

    // viewport of the wrapper (account for header)
    const wrapRect = wrap.getBoundingClientRect();
    const viewportTop = wrapRect.top + headerH;

    // box rect relative to viewport
    const boxRect = box.getBoundingClientRect();

    // how much of the box's top is hidden above the visible area of the wrapper
    const hiddenTop = Math.max(0, viewportTop - boxRect.top);

    // pad = base + your adjustable offset + exactly how much is hidden
    const pad = Math.min(maxPad, basePad + extraY + hiddenTop);
    broj.style.paddingTop = pad + 'px';
  });
}


function layoutNoOverlap(container) {
  // Uveri se da “container” ima prave elemente
  const cards = Array.from(container.querySelectorAll('.dodelaWrap'));
  console.log('found cards in this container:', cards.length);

  // Ako očekuješ više a dobijaš 1, proveri: da li si stvarno dodao više elemenata?
  // Brzi sanity check:
  // console.log('childElementCount:', container.childElementCount);

  // Osnovni no-overlap (primer: guraj sledeće ulevo/desno po potrebi)
  cards.sort((a, b) => a.offsetTop - b.offsetTop || a.offsetLeft - b.offsetLeft);

  for (let i = 1; i < cards.length; i++) {
    const prev = cards[i - 1].getBoundingClientRect();
    const curEl = cards[i];
    const cur = curEl.getBoundingClientRect();

    const sameRow = Math.abs(cur.top - prev.top) < 1; // ili prag po tvojoj mreži
    if (sameRow && cur.left < prev.right) {
      // pomeri trenutni odmah pored prethodnog
      const shift = (prev.right - cur.left) + 1;
      const currentLeft = parseFloat(getComputedStyle(curEl).left || '0');
      curEl.style.left = (currentLeft + shift) + 'px';
    }
  }
}




		  

  // Keep them updated every minute on the minute
  function scheduleTick() {
    const msToNextMinute = (60 - new Date().getSeconds()) * 1000 + 50;
    setTimeout(() => {
      scrollWrappersToNow();
      setInterval(scrollWrappersToNow, 300*1000);
    }, msToNextMinute);
  }
  //scheduleTick();

	</script>
		<div class="rasporedRadovaUzivo">
			<div id="majstori">
				
			</div>
			<script>
				for(var i=0;i<majstori.length;i++){
					

					if(majstori[i].dodele.length>0){
						var wrap = document.createElement("DIV");
						wrap.setAttribute("class","wrapper");
							var ime = document.createElement("DIV");
							ime.setAttribute("class","ime");
							ime.innerHTML = majstori[i].ime;
							wrap.appendChild(ime)

							var timesElem = document.createElement("DIV");
							timesElem.setAttribute("class","times");
							for(var j=0;j<times.length;j++){
								var timestamp = document.createElement("DIV");
								timestamp.setAttribute("class","timestamp");
								timestamp.innerHTML = times[j];
								timesElem.appendChild(timestamp);
							}
							wrap.appendChild(timesElem);

							var rtimesElem = document.createElement("DIV");
							rtimesElem.setAttribute("class","times relativeTimes");
							for(var j=0;j<times.length;j++){
								var timestamp = document.createElement("DIV");
								timestamp.setAttribute("class","timestamp");
								timestamp.innerHTML = times[j];
								rtimesElem.appendChild(timestamp);
							}
							wrap.appendChild(rtimesElem);

							var dodele = document.createElement("DIV");
							dodele.setAttribute("class","dodele");
							wrap.appendChild(dodele);

							var laser = document.createElement("DIV");
							laser.setAttribute("class","laser");
							wrap.appendChild(laser)
						document.getElementById("majstori").appendChild(wrap);
						dodele.style.height = rtimesElem.getBoundingClientRect().height+"px";

						for(var j=0;j<majstori[i].dodele.length;j++){
							var dodelaJson = majstori[i].dodele[j];
							var dodelaWrap = document.createElement("DIV");
							dodelaWrap.setAttribute("class","dodelaWrap");
							dodelaWrap.style.top = getTopForTime(dodelaJson.vremeDolaska)+"px"
							dodelaWrap.style.height = getHeightForDuration(dodelaJson.vremeRadova)+"px"
								var brojNaloga = document.createElement("DIV");
								brojNaloga.setAttribute("class","brojNaloga");
								brojNaloga.innerHTML = "<a href=\"/nalog/"+dodelaJson.nalog+"\" target=\"_blank\">"+dodelaJson.nalog+"</a>";
								dodelaWrap.appendChild(brojNaloga);

								var statusNaloga = document.createElement("DIV");
								statusNaloga.setAttribute("class","statusNaloga");
								statusNaloga.innerHTML = dodelaJson.nalogInfo.statusNaloga;
								dodelaWrap.appendChild(statusNaloga);

								/*var adresaNaloga = document.createElement("DIV");
								adresaNaloga.setAttribute("class","adresaNaloga");
								adresaNaloga.innerHTML = dodelaJson.nalogInfo.radnaJedinica+"<br>"+dodelaJson.nalogInfo.adresa;
								dodelaWrap.appendChild(adresaNaloga);*/
							dodele.appendChild(dodelaWrap);
						}
						//adjustLeftPositionsTight(dodele)

						//requestAnimationFrame(() => {
						  layoutNoOverlap(dodele); // or dodeleElem if you rename it
						//});
						const now = new Date();
						const nowMin = now.getHours() * 60 + now.getMinutes();

						
						const startMin = START_H * 60 + START_M;
						const endMin = END_H * 60 + END_M;
						const sample = wrap.querySelector('.times .timestamp');
						const slotH  = sample ? sample.offsetHeight : 0;
						const elapsed = nowMin - startMin;
						const wholeSlots = Math.floor(elapsed / STEP_MIN);
						const minutesIntoSlot = elapsed % STEP_MIN;
						const insideSlotOffset = (minutesIntoSlot / STEP_MIN) * slotH;

						const padTop = parseFloat(getComputedStyle(wrap).paddingTop) || 0;
						const topPx = padTop + wholeSlots * slotH + insideSlotOffset;
						laser.style.top = `${topPx}px`;
					}
				}

				setTimeout(function(){
					window.location.reload();
				},120000)
			</script>
		</div>
<%- include ("partials/footer") -%>